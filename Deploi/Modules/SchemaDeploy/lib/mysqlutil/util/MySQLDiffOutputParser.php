<?php
	namespace Deploi\Modules\SchemaDeploy\lib\MySQLUtil\Util;

	use Deploi\Util\Config;
	use PDO;
	use PDOException;
	use Deploi\Modules\SchemaDeploy\lib\MySQLUtil\Util\Server;
	use Exception;
	use SimpleXMLElement;

	/**
	 * Parses output generated by mysqldiff
	 */
	class MySQLDiffOutputParser
	{
		/**
		 *
		 */
		const COMPARE_FAILED = "Compare failed. One or more differences found.";
		/**
		 *
		 */
		const SERVER_CONNECTED = "%s on localhost: ... connected.";
		/**
		 *
		 */
		const MISSING_OBJECT = "WARNING: Objects in %s.%s but not in %s.%s:";
		/**
		 *
		 */
		const COMPARISON = "Comparing %s to %s                                    [%s]";

		/**
		 * @var Server
		 */
		private $local;

		/**
		 * @var Server
		 */
		private $remote;

		/**
		 * @var resource
		 */
		private $localConn;
		/**
		 * @var resource
		 */
		private $remoteConn;

		/**
		 * @var array
		 */
		private $log = array();

		/**
		 * @param Server $local
		 * @param Server $remote
		 * @param        $xml
		 */
		public function __construct(Server $local, Server $remote, $xml)
		{
			$this->local  = $local;
			$this->remote = $remote;

			// create connections and select schemas

			$this->localConn  = $this->local->getConnection();
			$this->remoteConn = $this->remote->getConnection();

			$this->log = array();

			$this->parse($xml);

			// close connections
			$this->localConn  = null;
			$this->remoteConn = null;
		}

		/**
		 * @param $text
		 *
		 * @throws \Exception
		 */
		private function parse($text)
		{
			try
			{
				$text = $this->sanitizeOutput($text);
				if(!$text)
				{
					throw new Exception("Empty output");
				}

				$xml = new SimpleXMLElement($text);
				if(!$xml)
					return;

				$error = trim((string) $xml->error);
				if(!empty($error))
					$this->parseErrors($error);

				if($xml->missing && count($xml->missing->children()) > 0)
					$this->parseMissing($xml->missing);

				if($xml->transformations && count($xml->transformations->children()) > 0)
					$this->parseTransformations($xml->transformations);
			}
			catch(Exception $e)
			{
				print_r($e);
			}
		}

		/**
		 * Strip all blank lines and lines beginning with a hash (#)
		 *
		 * @param $text
		 *
		 * @return string
		 */
		private function sanitizeOutput($text)
		{
			$text = trim($text);
			if(empty($text))
				return null;

			$lines    = explode(PHP_EOL, $text);
			$stripped = array();

			foreach($lines as $line)
			{
				$line = trim($line);

				if(empty($line))
					continue;

				$pos = strpos($line, "#");
				if($pos !== FALSE && $pos >= 0)
					continue;

				$stripped[] = $line;
			}

			return implode(PHP_EOL, $stripped);
		}

		/**
		 * @param $error
		 *
		 * @throws \Exception
		 */
		private function parseErrors($error)
		{
			if(empty($error))
				return;

			throw new Exception("$error");
		}

		/**
		 * @param \SimpleXMLElement $missing
		 */
		private function parseMissing(SimpleXMLElement $missing)
		{
			if(empty($missing))
				return;

			foreach($missing->children() as $element)
			{
				$host       = trim($element["host"]);
				$identifier = trim($element["identifier"]);
				$type       = trim($element["type"]);

				// if an element is missing from one server, find its creation syntax in the other
				$direction    = Config::get('schemadeploy.direction');
				$sourceServer = $direction == "forward" ? $this->local : $this->remote;
				$targetServer = $direction == "forward" ? $this->remote : $this->local;

				// check for non-existent tables on source that exist on target
				if(!$sourceServer->tableExists($identifier) && $targetServer->tableExists($identifier))
				{
					$destructive = (bool) Config::get("schemadeploy.destructive");
					if(!$destructive)
						continue;

					$targetServer->execute("DROP TABLE `$identifier`");
				}
				else
				{
					$createSyntax = $this->getCreateSyntax($sourceServer, $identifier, $type);
					if(empty($createSyntax))
						continue;

					$targetServer->execute($createSyntax, PDO::FETCH_ASSOC, true, true, true);
				}
			}
		}

		/**
		 * @param \SimpleXMLElement $transformations
		 * @param string            $direction
		 */
		private function parseTransformations(SimpleXMLElement $transformations, $direction = "forward")
		{
			if(empty($transformations))
				return;

			foreach($transformations->children() as $element)
			{
				if($element && $element->$direction)
				{
					$element = $element->$direction;

					$server = trim($element["changes-for"]) == "server1" ? $this->local : $this->remote;
					$query  = trim($element);

					$server->execute($query, PDO::FETCH_ASSOC, true, true, true);
				}
			}
		}

		/**
		 * @param Server $server
		 * @param        $identifier
		 * @param        $type
		 *
		 * @return null
		 * @throws \PDOException
		 */
		private function getCreateSyntax(Server $server, $identifier, $type)
		{
			try
			{
				$results = $server->execute("SHOW CREATE " . strtoupper($type) . " `$identifier`", PDO::FETCH_ASSOC, false);
			}
			catch(PDOException $e)
			{
				throw $e;
			}

			if(count($results) < 1)
				return null;

			return $results[0]["Create Table"];
		}
	}
